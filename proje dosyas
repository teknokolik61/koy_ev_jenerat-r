#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>
#include <ArduinoJson.h>
#include <Preferences.h>

// =====================
// WiFi / Telegram
// =====================
const char* WIFI_SSID = "SSID";
const char* WIFI_PASS = "PASSWORD";

const char* BOT_TOKEN = "123456:ABCDEF...";
const char* CHAT_ID   = "-1001234567890"; // grup: -100.. | ki≈üi: "123.."

WiFiClientSecure secured_client;
UniversalTelegramBot bot(BOT_TOKEN, secured_client);

unsigned long lastBotPollMs = 0;
const unsigned long BOT_POLL_INTERVAL_MS = 1200;

// =====================
// NVS (Preferences)
// =====================
Preferences prefs;
const char* NVS_NS = "genctrl";

// =====================
// AUTH (Dynamic whitelist + names)
// =====================
const int MASTER_ADMIN_ID = 111111111; // SENƒ∞N Telegram numeric user_id (silinemez)

const int MAX_ALLOWED = 20;

struct AllowedEntry {
  int id;
  String name;
};

AllowedEntry allowedList[MAX_ALLOWED];
int allowedCount = 0;

// =====================
// Pins (ESP32 ADC1 pins)
// =====================
const int PIN_ADC_MAINS = 34; // ZMPT101B OUT (mains)
const int PIN_ADC_GEN   = 35; // ZMPT101B OUT (generator)

const int PIN_STARTER_RELAY = 26; // START
const int PIN_IGN_RELAY     = 27; // IGN
const int PIN_FUEL_RELAY    = 25; // FUEL

// R√∂le kartƒ± LOW tetiklemeli:
const int RELAY_ACTIVE_LEVEL = LOW;

// =====================
// Modes
// =====================
bool autoMode = true;

// =====================
// Defaults (thresholds)
// =====================
const float D_MAINS_LOW_ALERT_V  = 190.0;
const float D_MAINS_HIGH_ALERT_V = 240.0;
const float D_MAINS_OK_MIN_V     = 210.0;
const float D_MAINS_OK_MAX_V     = 230.0;
const float D_MAINS_CRITICAL_V   = 100.0;
const float D_GEN_RUNNING_V      = 150.0;
const float D_ALERT_HYST_V       = 3.0;

// Runtime thresholds (NVS‚Äôden y√ºklenir)
float MAINS_LOW_ALERT_V  = D_MAINS_LOW_ALERT_V;
float MAINS_HIGH_ALERT_V = D_MAINS_HIGH_ALERT_V;
float MAINS_OK_MIN_V     = D_MAINS_OK_MIN_V;
float MAINS_OK_MAX_V     = D_MAINS_OK_MAX_V;
float MAINS_CRITICAL_V   = D_MAINS_CRITICAL_V;
float GEN_RUNNING_V      = D_GEN_RUNNING_V;
float ALERT_HYST_V       = D_ALERT_HYST_V;

// =====================
// Debounce / Filter
// =====================
const int GEN_ON_CONFIRM_COUNT  = 3;
const int GEN_OFF_CONFIRM_COUNT = 5;

int genAboveCount = 0;
int genBelowCount = 0;

// =====================
// RMS sampling settings
// =====================
// ZMPT101B i√ßin √ßok kritik: bunu kalibre edeceksin.
const int RMS_SAMPLES = 700;            // 700-1200 arasƒ± iyi
const int RMS_SAMPLE_DELAY_US = 200;    // 200us => 5kHz

float CAL_MAINS = 0.310; // Kalibrasyon katsayƒ±sƒ± (mains)
float CAL_GEN   = 0.310; // Kalibrasyon katsayƒ±sƒ± (gen)

// =====================
// Timers
// =====================
const unsigned long REPLY_TIMEOUT_MS = 60UL * 1000UL;
const unsigned long MAINS_RETURN_STOP_DELAY_MS = 30UL * 1000UL;

// Periyodik rapor (NVS‚Äôden y√ºklenir)
unsigned long PERIODIC_REPORT_MS = 60UL * 1000UL;

// =====================
// State machine
// =====================
enum SystemState {
  ST_MONITOR,
  ST_WAIT_REPLY,
  ST_PRECHECK_AFTER_YES,
  ST_STARTING,
  ST_COOLDOWN
};

SystemState state = ST_MONITOR;

// Alarm latch
bool lowAlertLatched  = false;
bool highAlertLatched = false;

// Reply state
bool awaitingReply = false;
unsigned long waitReplyStartMs = 0;

// Start procedure timers
unsigned long lastGenCheckMs = 0;
int starterSecondCounter = 0;
unsigned long cooldownStartMs = 0;

// Generator running / stop scheduling
bool generatorRunning = false;
unsigned long mainsNormalSinceMs = 0;
bool stopScheduled = false;

unsigned long lastPeriodicReportMs = 0;

// Last alarm
String lastAlarm = "Yok";
unsigned long lastAlarmMs = 0;

// =====================
// Forward declarations
// =====================
void saveAllowedListToNVS();
void loadAllowedListFromNVS();
void loadSettingsFromNVS();
void sendStatus();
void sendThresholds();
void sendBootReport();
void checkTelegram();

// =====================
// Low-level helpers
// =====================
void relayWrite(int pin, bool on) {
  digitalWrite(pin, on ? RELAY_ACTIVE_LEVEL : !RELAY_ACTIVE_LEVEL);
}
void starter(bool on) { relayWrite(PIN_STARTER_RELAY, on); }
void ign(bool on)     { relayWrite(PIN_IGN_RELAY, on); }
void fuel(bool on)    { relayWrite(PIN_FUEL_RELAY, on); }

void allOutputsOff() { starter(false); ign(false); fuel(false); }

void sendTG(const String& msg) { bot.sendMessage(CHAT_ID, msg, ""); }

String normalizeTR(String s) { s.toLowerCase(); s.trim(); return s; }

bool isMaster(int userId) { return userId == MASTER_ADMIN_ID; }

String onOffFromPin(int pin) {
  return (digitalRead(pin) == RELAY_ACTIVE_LEVEL) ? "ON" : "OFF";
}

String stateToStr(SystemState st) {
  switch (st) {
    case ST_MONITOR: return "MONITOR";
    case ST_WAIT_REPLY: return "WAIT_REPLY";
    case ST_PRECHECK_AFTER_YES: return "PRECHECK";
    case ST_STARTING: return "STARTING";
    case ST_COOLDOWN: return "COOLDOWN";
    default: return "UNKNOWN";
  }
}

String rssiToQuality(int rssi) {
  if (rssi >= -55) return "M√ºkemmel";
  if (rssi >= -67) return "ƒ∞yi";
  if (rssi >= -75) return "Orta";
  if (rssi >= -85) return "Zayƒ±f";
  return "√áok zayƒ±f";
}

// =====================
// Allowed list ops
// =====================
int findAllowedIndex(int userId) {
  for (int i = 0; i < allowedCount; i++) {
    if (allowedList[i].id == userId) return i;
  }
  return -1;
}

bool isAllowedUser(int userId) {
  if (userId == MASTER_ADMIN_ID) return true;
  return findAllowedIndex(userId) >= 0;
}

bool addAllowed(int userId) {
  if (userId == MASTER_ADMIN_ID) return true;
  if (findAllowedIndex(userId) >= 0) return true;
  if (allowedCount >= MAX_ALLOWED) return false;
  allowedList[allowedCount].id = userId;
  allowedList[allowedCount].name = ""; // ilk mesajla dolacak
  allowedCount++;
  return true;
}

bool removeAllowed(int userId) {
  if (userId == MASTER_ADMIN_ID) return false;
  int idx = findAllowedIndex(userId);
  if (idx < 0) return false;
  for (int i = idx; i < allowedCount - 1; i++) {
    allowedList[i] = allowedList[i + 1];
  }
  allowedCount--;
  return true;
}

bool setAllowedName(int userId, const String& newName) {
  if (userId == MASTER_ADMIN_ID) return false;
  int idx = findAllowedIndex(userId);
  if (idx < 0) return false;

  String n = newName;
  n.trim();
  if (n.length() == 0) return false;

  allowedList[idx].name = n;
  saveAllowedListToNVS();
  return true;
}

void updateNameIfNeeded(int userId, const String& fromName) {
  if (userId == MASTER_ADMIN_ID) return;
  int idx = findAllowedIndex(userId);
  if (idx < 0) return;

  if (allowedList[idx].name.length() == 0 || allowedList[idx].name != fromName) {
    allowedList[idx].name = fromName;
    saveAllowedListToNVS();
  }
}

String allowedListToString() {
  String s = "üëÆ Yetkili liste:\n";
  s += "MASTER: " + String(MASTER_ADMIN_ID) + "\n";
  if (allowedCount == 0) {
    s += "(Ek yetkili yok)";
    return s;
  }
  for (int i = 0; i < allowedCount; i++) {
    String nm = allowedList[i].name;
    if (nm.length() == 0) nm = "Tanƒ±msƒ±z";
    s += String(i + 1) + ") " + nm + " (" + String(allowedList[i].id) + ")\n";
  }
  return s;
}

// =====================
// NVS - Allowed list (JSON)
// key: allow2
// schema: {"users":[{"id":123,"name":"Ahmet"}, ...]}
// =====================
void saveAllowedListToNVS() {
  StaticJsonDocument<1024> doc;
  JsonArray arr = doc.createNestedArray("users");
  for (int i = 0; i < allowedCount; i++) {
    JsonObject o = arr.createNestedObject();
    o["id"] = allowedList[i].id;
    o["name"] = allowedList[i].name;
  }
  String out;
  serializeJson(doc, out);

  prefs.begin(NVS_NS, false);
  prefs.putString("allow2", out);
  prefs.end();
}

void loadAllowedListFromNVS() {
  allowedCount = 0;

  prefs.begin(NVS_NS, true);
  String s = prefs.getString("allow2", "");
  prefs.end();

  if (s.length() == 0) return;

  StaticJsonDocument<1024> doc;
  DeserializationError err = deserializeJson(doc, s);
  if (err) return;

  JsonArray arr = doc["users"].as<JsonArray>();
  for (JsonVariant v : arr) {
    if (allowedCount >= MAX_ALLOWED) break;
    int id = v["id"] | 0;
    const char* nm = v["name"] | "";
    if (id > 0 && id != MASTER_ADMIN_ID) {
      allowedList[allowedCount].id = id;
      allowedList[allowedCount].name = String(nm);
      allowedCount++;
    }
  }
}

// =====================
// NVS settings load/save
// =====================
void saveThresholdsToNVS() {
  prefs.begin(NVS_NS, false);
  prefs.putFloat("low", MAINS_LOW_ALERT_V);
  prefs.putFloat("high", MAINS_HIGH_ALERT_V);
  prefs.putFloat("okmin", MAINS_OK_MIN_V);
  prefs.putFloat("okmax", MAINS_OK_MAX_V);
  prefs.putFloat("crit", MAINS_CRITICAL_V);
  prefs.putFloat("genrun", GEN_RUNNING_V);
  prefs.putFloat("hyst", ALERT_HYST_V);
  prefs.end();
}

void saveReportSecToNVS(uint32_t sec) {
  prefs.begin(NVS_NS, false);
  prefs.putUInt("repsec", sec);
  prefs.end();
}

void saveAutoModeToNVS(bool on) {
  prefs.begin(NVS_NS, false);
  prefs.putBool("auto", on);
  prefs.end();
}

void setDefaultsAndSave() {
  MAINS_LOW_ALERT_V  = D_MAINS_LOW_ALERT_V;
  MAINS_HIGH_ALERT_V = D_MAINS_HIGH_ALERT_V;
  MAINS_OK_MIN_V     = D_MAINS_OK_MIN_V;
  MAINS_OK_MAX_V     = D_MAINS_OK_MAX_V;
  MAINS_CRITICAL_V   = D_MAINS_CRITICAL_V;
  GEN_RUNNING_V      = D_GEN_RUNNING_V;
  ALERT_HYST_V       = D_ALERT_HYST_V;

  PERIODIC_REPORT_MS = 60UL * 1000UL;
  autoMode = true;

  saveThresholdsToNVS();
  saveReportSecToNVS(60);
  saveAutoModeToNVS(true);
}

void loadSettingsFromNVS() {
  prefs.begin(NVS_NS, true);

  MAINS_LOW_ALERT_V  = prefs.getFloat("low",   D_MAINS_LOW_ALERT_V);
  MAINS_HIGH_ALERT_V = prefs.getFloat("high",  D_MAINS_HIGH_ALERT_V);
  MAINS_OK_MIN_V     = prefs.getFloat("okmin", D_MAINS_OK_MIN_V);
  MAINS_OK_MAX_V     = prefs.getFloat("okmax", D_MAINS_OK_MAX_V);
  MAINS_CRITICAL_V   = prefs.getFloat("crit",  D_MAINS_CRITICAL_V);
  GEN_RUNNING_V      = prefs.getFloat("genrun",D_GEN_RUNNING_V);
  ALERT_HYST_V       = prefs.getFloat("hyst",  D_ALERT_HYST_V);

  uint32_t repSec = prefs.getUInt("repsec", 60);
  if (repSec < 10) repSec = 10;
  if (repSec > 3600) repSec = 3600;
  PERIODIC_REPORT_MS = (unsigned long)repSec * 1000UL;

  autoMode = prefs.getBool("auto", true);
  prefs.end();

  loadAllowedListFromNVS();
}

// =====================
// Measurement (RMS)
// =====================
float readVoltageRMS(int adcPin, float calFactor) {
  uint32_t sum = 0;
  uint32_t sumSq = 0;

  for (int i = 0; i < RMS_SAMPLES; i++) {
    int v = analogRead(adcPin);
    sum += (uint32_t)v;
    delayMicroseconds(RMS_SAMPLE_DELAY_US);
  }
  float mean = (float)sum / (float)RMS_SAMPLES;

  for (int i = 0; i < RMS_SAMPLES; i++) {
    int v = analogRead(adcPin);
    float ac = (float)v - mean;
    sumSq += (uint32_t)(ac * ac);
    delayMicroseconds(RMS_SAMPLE_DELAY_US);
  }

  float meanSq = (float)sumSq / (float)RMS_SAMPLES;
  float rmsAdc = sqrtf(meanSq);
  return rmsAdc * calFactor;
}

float readMainsV() { return readVoltageRMS(PIN_ADC_MAINS, CAL_MAINS); }
float readGenV()   { return readVoltageRMS(PIN_ADC_GEN,   CAL_GEN);   }

// =====================
// Logic helpers
// =====================
void resetAlertLatchesIfNormal(float mainsV) {
  if (mainsV > (MAINS_LOW_ALERT_V + ALERT_HYST_V))  lowAlertLatched = false;
  if (mainsV < (MAINS_HIGH_ALERT_V - ALERT_HYST_V)) highAlertLatched = false;
}

bool parseKeyValue(const String& token, const String& key, float &outVal) {
  String prefix = key + "=";
  if (!token.startsWith(prefix)) return false;
  outVal = token.substring(prefix.length()).toFloat();
  return true;
}

// =====================
// Status / Boot report
// =====================
String resetReasonToStr(esp_reset_reason_t r) {
  switch (r) {
    case ESP_RST_POWERON: return "POWERON";
    case ESP_RST_EXT: return "EXT_RESET";
    case ESP_RST_SW: return "SW_RESET";
    case ESP_RST_PANIC: return "PANIC";
    case ESP_RST_INT_WDT: return "INT_WDT";
    case ESP_RST_TASK_WDT: return "TASK_WDT";
    case ESP_RST_WDT: return "WDT";
    case ESP_RST_DEEPSLEEP: return "DEEPSLEEP";
    case ESP_RST_BROWNOUT: return "BROWNOUT";
    case ESP_RST_SDIO: return "SDIO";
    default: return "UNKNOWN";
  }
}

void sendThresholds() {
  String msg;
  msg += "‚öôÔ∏è Thresholds:\n";
  msg += "low=" + String(MAINS_LOW_ALERT_V,1) + "V\n";
  msg += "high=" + String(MAINS_HIGH_ALERT_V,1) + "V\n";
  msg += "okmin=" + String(MAINS_OK_MIN_V,1) + "V\n";
  msg += "okmax=" + String(MAINS_OK_MAX_V,1) + "V\n";
  msg += "critical=" + String(MAINS_CRITICAL_V,1) + "V\n";
  msg += "genrun=" + String(GEN_RUNNING_V,1) + "V\n";
  msg += "hyst=" + String(ALERT_HYST_V,1) + "V\n";
  msg += "report=" + String(PERIODIC_REPORT_MS/1000UL) + " sn\n";
  msg += "auto=" + String(autoMode ? "ON" : "OFF");
  sendTG(msg);
}

void sendStatus() {
  float mainsV = readMainsV();
  float genV   = readGenV();
  int rssi = WiFi.RSSI();

  String msg;
  msg += "üìü /status\n";
  msg += "Auto: " + String(autoMode ? "ON" : "OFF") + "\n";
  msg += "State: " + stateToStr(state) + "\n";
  msg += "GenRunning: " + String(generatorRunning ? "YES" : "NO") + "\n";
  msg += "≈ûebeke: " + String(mainsV, 1) + "V\n";
  msg += "Jenerat√∂r: " + String(genV, 1) + "V\n";
  msg += "Son alarm: " + lastAlarm + "\n";
  msg += "Wi-Fi: " + String(rssi) + " dBm (" + rssiToQuality(rssi) + ")\n";
  msg += "Rapor: " + String(PERIODIC_REPORT_MS/1000UL) + " sn\n";
  msg += "√áƒ±kƒ±≈ülar: START=" + onOffFromPin(PIN_STARTER_RELAY);
  msg += " IGN=" + onOffFromPin(PIN_IGN_RELAY);
  msg += " FUEL=" + onOffFromPin(PIN_FUEL_RELAY);

  if (stopScheduled) {
    unsigned long left = (MAINS_RETURN_STOP_DELAY_MS - (millis() - mainsNormalSinceMs)) / 1000UL;
    msg += "\nStop planlƒ±: " + String(left) + " sn sonra";
  }
  sendTG(msg);
}

void sendBootReport() {
  float mainsV = readMainsV();
  float genV = readGenV();
  int rssi = WiFi.RSSI();

  String msg;
  msg += "üîÑ ESP32 yeniden ba≈üladƒ±\n";
  msg += "Reset: " + resetReasonToStr(esp_reset_reason()) + "\n";
  msg += "Auto: " + String(autoMode ? "ON" : "OFF") + "\n";
  msg += "State: " + stateToStr(state) + "\n";
  msg += "≈ûebeke: " + String(mainsV,1) + "V\n";
  msg += "Jenerat√∂r: " + String(genV,1) + "V\n";
  msg += "GenRunning: " + String(generatorRunning ? "YES" : "NO") + "\n";
  msg += "Wi-Fi: " + String(rssi) + " dBm (" + rssiToQuality(rssi) + ")\n";
  msg += "√áƒ±kƒ±≈ülar: START=" + onOffFromPin(PIN_STARTER_RELAY);
  msg += " IGN=" + onOffFromPin(PIN_IGN_RELAY);
  msg += " FUEL=" + onOffFromPin(PIN_FUEL_RELAY);
  sendTG(msg);
}

// Boot sƒ±rasƒ±nda hƒ±zlƒ± ‚ÄúgenRunning‚Äù tahmini (3 kƒ±sa okuma)
void bootDetectGeneratorRunning() {
  int hits = 0;
  for (int i = 0; i < 3; i++) {
    float g = readGenV();
    if (g > GEN_RUNNING_V) hits++;
    delay(150);
  }
  generatorRunning = (hits >= 2);
  genAboveCount = generatorRunning ? GEN_ON_CONFIRM_COUNT : 0;
  genBelowCount = generatorRunning ? 0 : GEN_OFF_CONFIRM_COUNT;
}

// =====================
// Generator control logic
// =====================
void prepareGeneratorRun() { ign(true); fuel(true); }

void stopGeneratorNow(const String& why) {
  starter(false);
  fuel(false);
  ign(false);

  generatorRunning = false;
  stopScheduled = false;
  mainsNormalSinceMs = 0;

  genAboveCount = 0;
  genBelowCount = 0;

  sendTG("üõë Jenerat√∂r STOP: " + why);
}

void startProcedureBegin(const String& why) {
  if (state == ST_STARTING || state == ST_COOLDOWN) {
    sendTG("‚ÑπÔ∏è Zaten √ßalƒ±≈ütƒ±rma d√∂ng√ºs√ºndeyim. (" + why + ")");
    return;
  }
  sendTG("‚ñ∂Ô∏è Jenerat√∂r √ßalƒ±≈ütƒ±rma prosed√ºr√º ba≈ülƒ±yor. (" + why + ")");
  prepareGeneratorRun();
  starterSecondCounter = 0;
  lastGenCheckMs = 0;
  starter(true);
  state = ST_STARTING;
}

void handleMainsReturnStopLogic(float mainsV) {
  bool mainsNormal = (mainsV >= MAINS_OK_MIN_V && mainsV <= MAINS_OK_MAX_V);

  if (generatorRunning) {
    if (mainsNormal) {
      if (!stopScheduled) {
        stopScheduled = true;
        mainsNormalSinceMs = millis();
        sendTG("‚úÖ ≈ûebeke normale d√∂nd√º (" + String(mainsV,1) + "V). 30 sn sonra jenerat√∂r√º durduracaƒüƒ±m.");
      }
    } else {
      if (stopScheduled) {
        stopScheduled = false;
        mainsNormalSinceMs = 0;
        sendTG("‚ö†Ô∏è ≈ûebeke tekrar normal dƒ±≈üƒ±na √ßƒ±ktƒ±. Stop planƒ± iptal.");
      }
    }

    if (stopScheduled && (millis() - mainsNormalSinceMs >= MAINS_RETURN_STOP_DELAY_MS)) {
      stopGeneratorNow("≈ûebeke 30 sn normal kaldƒ±");
    }
  } else {
    stopScheduled = false;
    mainsNormalSinceMs = 0;
  }
}

void handlePeriodicReport(float mainsV, float genV) {
  if (!generatorRunning) return;

  bool mainsNormal = (mainsV >= MAINS_OK_MIN_V && mainsV <= MAINS_OK_MAX_V);
  if (mainsNormal) return;

  if (millis() - lastPeriodicReportMs >= PERIODIC_REPORT_MS) {
    lastPeriodicReportMs = millis();
    String msg = "üì° Durum bildirimi:\n";
    msg += "≈ûebeke: " + String(mainsV,1) + "V\n";
    msg += "Jenerat√∂r: " + String(genV,1) + "V\n";
    msg += "Auto: " + String(autoMode ? "ON" : "OFF");
    sendTG(msg);
  }
}

void updateGeneratorRunningDebounced(float genV) {
  if (genV > GEN_RUNNING_V) {
    genAboveCount++;
    genBelowCount = 0;
  } else {
    genBelowCount++;
    genAboveCount = 0;
  }

  if (!generatorRunning && genAboveCount >= GEN_ON_CONFIRM_COUNT) {
    generatorRunning = true;
    lastPeriodicReportMs = millis();
    sendTG("‚úÖ Jenerat√∂r √ßalƒ±≈üƒ±yor (3/3 onay). (" + String(genV,1) + "V)");
  }

  if (generatorRunning && state == ST_MONITOR && genBelowCount >= GEN_OFF_CONFIRM_COUNT) {
    generatorRunning = false;
    stopScheduled = false;
    mainsNormalSinceMs = 0;
    sendTG("‚ÑπÔ∏è Jenerat√∂r durdu (5/5 onay). (" + String(genV,1) + "V)");
  }
}

// =====================
// Alarm question flow
// =====================
void askGeneratorQuestion(const String& reason, float v) {
  lastAlarm = reason + " (" + String(v,1) + "V)";
  lastAlarmMs = millis();

  String msg = reason + "\n";
  msg += "≈ûebeke: " + String(v, 1) + "V\n";
  msg += "Jenerat√∂r √ßalƒ±≈ütƒ±rayƒ±m mƒ±? (evet / hayƒ±r)\n";
  msg += "Komutlar: /status";
  sendTG(msg);

  awaitingReply = true;
  waitReplyStartMs = millis();
  state = ST_WAIT_REPLY;
}

// =====================
// Telegram handling
// =====================
void handleTelegramText(const String& text, int fromId, const String& fromName) {
  String t = normalizeTR(text);

  // Herkes /myid kullanabilir
  if (t == "/myid") {
    sendTG("üÜî " + fromName + " user_id: " + String(fromId));
    return;
  }

  // allowed kullanƒ±cƒ± ise adƒ±nƒ± otomatik g√ºncelle
  if (isAllowedUser(fromId)) {
    updateNameIfNeeded(fromId, fromName);
  }

  // Yetkisiz komut raporu
  if (!isAllowedUser(fromId)) {
    if (t.startsWith("/")) {
      sendTG("‚õî Yetkisiz komut. Kullanƒ±cƒ±: " + fromName + " (" + String(fromId) + ")");
    }
    return;
  }

  // ========== MASTER-ONLY whitelist y√∂netimi ==========
  if (t == "/liste") {
    sendTG(allowedListToString());
    return;
  }

  if (t.startsWith("/ekle")) {
    if (!isMaster(fromId)) { sendTG("‚õî Bu komut sadece MASTER i√ßin."); return; }
    int sp = text.indexOf(' ');
    if (sp < 0) { sendTG("Kullanƒ±m: /ekle 123456789"); return; }
    int id = text.substring(sp + 1).toInt();
    if (id <= 0) { sendTG("‚ùå Ge√ßersiz id."); return; }
    if (!addAllowed(id)) { sendTG("‚ùå Liste dolu (max " + String(MAX_ALLOWED) + ")."); return; }
    saveAllowedListToNVS();
    sendTG("‚úÖ Eklendi: " + String(id) + " (isim ilk mesajla eklenecek)");
    return;
  }

  if (t.startsWith("/sil")) {
    if (!isMaster(fromId)) { sendTG("‚õî Bu komut sadece MASTER i√ßin."); return; }
    int sp = text.indexOf(' ');
    if (sp < 0) { sendTG("Kullanƒ±m: /sil 123456789"); return; }
    int id = text.substring(sp + 1).toInt();
    if (id == MASTER_ADMIN_ID) { sendTG("‚ùå MASTER silinemez."); return; }
    if (!removeAllowed(id)) { sendTG("‚ÑπÔ∏è Listede yok: " + String(id)); return; }
    saveAllowedListToNVS();
    sendTG("‚úÖ Silindi: " + String(id));
    return;
  }

  // /isim <id> <isim soyisim...>  (Master-only)
  if (t.startsWith("/isim")) {
    if (!isMaster(fromId)) { sendTG("‚õî Bu komut sadece MASTER i√ßin."); return; }

    int firstSpace = text.indexOf(' ');
    if (firstSpace < 0) { sendTG("Kullanƒ±m: /isim 123456789 Mehmet Yƒ±lmaz"); return; }
    int secondSpace = text.indexOf(' ', firstSpace + 1);
    if (secondSpace < 0) { sendTG("Kullanƒ±m: /isim 123456789 Mehmet Yƒ±lmaz"); return; }

    String idStr = text.substring(firstSpace + 1, secondSpace);
    int id = idStr.toInt();
    if (id <= 0) { sendTG("‚ùå Ge√ßersiz id."); return; }

    String newName = text.substring(secondSpace + 1);
    newName.trim();
    if (newName.length() == 0) { sendTG("‚ùå ƒ∞sim bo≈ü olamaz."); return; }

    if (!setAllowedName(id, newName)) {
      sendTG("‚ùå Bu ID listede yok veya master ID. √ñnce /ekle ile ekle, sonra /liste ile kontrol et.");
      return;
    }

    sendTG("‚úÖ ƒ∞sim g√ºncellendi: " + newName + " (" + String(id) + ")");
    return;
  }

  // ========== Normal komutlar (Yetkililer) ==========
  if (t == "/status") { sendStatus(); return; }
  if (t == "/get_thresholds") { sendThresholds(); return; }

  if (t == "/get_report") {
    sendTG("‚è±Ô∏è Rapor s√ºresi: " + String(PERIODIC_REPORT_MS/1000UL) + " sn");
    return;
  }

  if (t == "/auto_on") {
    autoMode = true;
    saveAutoModeToNVS(true);
    sendTG("‚úÖ Otomatik mod A√áIK.");
    return;
  }

  if (t == "/auto_off") {
    autoMode = false;
    saveAutoModeToNVS(false);
    awaitingReply = false;
    if (state == ST_WAIT_REPLY) state = ST_MONITOR;
    sendTG("‚õî Otomatik mod KAPALI.");
    return;
  }

  if (t == "/start") { startProcedureBegin("manuel /start"); return; }

  if (t == "/stop")  {
    stopGeneratorNow("manuel /stop");
    state = ST_MONITOR;
    awaitingReply = false;
    return;
  }

  if (t == "/defaults") {
    setDefaultsAndSave();
    sendTG("‚ôªÔ∏è Varsayƒ±lan ayarlar y√ºklendi ve kaydedildi.");
    sendThresholds();
    return;
  }

  // /set_report 30
  if (t.startsWith("/set_report")) {
    int sp = text.indexOf(' ');
    if (sp < 0) { sendTG("Kullanƒ±m: /set_report 30  (10..3600 sn)"); return; }
    uint32_t sec = (uint32_t)text.substring(sp + 1).toInt();
    if (sec < 10) sec = 10;
    if (sec > 3600) sec = 3600;
    PERIODIC_REPORT_MS = (unsigned long)sec * 1000UL;
    saveReportSecToNVS(sec);
    sendTG("‚úÖ Rapor s√ºresi ayarlandƒ±: " + String(sec) + " sn");
    return;
  }

  // /set_thresholds low=.. high=.. okmin=.. okmax=.. critical=.. genrun=.. hyst=..
  if (t.startsWith("/set_thresholds")) {
    float v;
    bool changed = false;

    String tn = normalizeTR(text);
    int idx = 0;
    while (idx >= 0) {
      int next = tn.indexOf(' ', idx);
      String token = (next < 0) ? tn.substring(idx) : tn.substring(idx, next);
      idx = (next < 0) ? -1 : next + 1;

      if (token == "/set_thresholds") continue;

      if (parseKeyValue(token, "low", v))      { MAINS_LOW_ALERT_V = v; changed = true; continue; }
      if (parseKeyValue(token, "high", v))     { MAINS_HIGH_ALERT_V = v; changed = true; continue; }
      if (parseKeyValue(token, "okmin", v))    { MAINS_OK_MIN_V = v; changed = true; continue; }
      if (parseKeyValue(token, "okmax", v))    { MAINS_OK_MAX_V = v; changed = true; continue; }
      if (parseKeyValue(token, "critical", v)) { MAINS_CRITICAL_V = v; changed = true; continue; }
      if (parseKeyValue(token, "genrun", v))   { GEN_RUNNING_V = v; changed = true; continue; }
      if (parseKeyValue(token, "hyst", v))     { ALERT_HYST_V = v; changed = true; continue; }
    }

    if (!changed) {
      sendTG("Kullanƒ±m: /set_thresholds low=190 high=240 okmin=210 okmax=230 critical=100 genrun=150 hyst=3");
      return;
    }

    if (MAINS_OK_MIN_V >= MAINS_OK_MAX_V) {
      sendTG("‚ùå Hata: okmin okmax'tan k√º√ß√ºk olmalƒ±. Deƒüi≈üiklik iptal edildi.");
      loadSettingsFromNVS();
      return;
    }

    saveThresholdsToNVS();
    sendTG("‚úÖ Thresholds kaydedildi.");
    sendThresholds();
    return;
  }

  // Alarm sorusuna cevap (evet/hayƒ±r)
  if (state == ST_WAIT_REPLY && awaitingReply) {
    if (t == "evet" || t == "e" || t == "yes") {
      awaitingReply = false;
      state = ST_PRECHECK_AFTER_YES;
      sendTG("‚úÖ Onay alƒ±ndƒ±. ≈ûebeke tekrar kontrol ediliyor...");
      return;
    }
    if (t == "hayƒ±r" || t == "h" || t == "no") {
      awaitingReply = false;
      state = ST_MONITOR;
      sendTG("üëç Tamam. ƒ∞≈ülem yapƒ±lmadƒ±.");
      return;
    }
  }
}

void checkTelegram() {
  if (millis() - lastBotPollMs < BOT_POLL_INTERVAL_MS) return;
  lastBotPollMs = millis();

  int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
  while (numNewMessages) {
    for (int i = 0; i < numNewMessages; i++) {
      if (bot.messages[i].chat_id != String(CHAT_ID)) continue;
      handleTelegramText(bot.messages[i].text, bot.messages[i].from_id, bot.messages[i].from_name);
    }
    numNewMessages = bot.getUpdates(bot.last_message_received + 1);
  }
}

// =====================
// setup / loop
// =====================
void setup() {
  Serial.begin(115200);

  pinMode(PIN_STARTER_RELAY, OUTPUT);
  pinMode(PIN_IGN_RELAY, OUTPUT);
  pinMode(PIN_FUEL_RELAY, OUTPUT);
  allOutputsOff();

  analogReadResolution(12);
  analogSetAttenuation(ADC_11db);

  loadSettingsFromNVS();

  WiFi.begin(WIFI_SSID, WIFI_PASS);
  while (WiFi.status() != WL_CONNECTED) {
    delay(300);
    Serial.print(".");
  }

  secured_client.setInsecure();

  // Boot anƒ±nda jenerat√∂r √ßalƒ±≈üƒ±yor mu hƒ±zlƒ± tahmin
  bootDetectGeneratorRunning();

  // Boot raporu: ≈üebeke/gen voltaj + √ßƒ±kƒ±≈ülar + reset reason
  sendBootReport();
}

void loop() {
  checkTelegram();

  float mainsV = readMainsV();
  float genV   = readGenV();

  updateGeneratorRunningDebounced(genV);

  handleMainsReturnStopLogic(mainsV);
  handlePeriodicReport(mainsV, genV);

  // Reply timeout
  if (state == ST_WAIT_REPLY && awaitingReply) {
    if (millis() - waitReplyStartMs > REPLY_TIMEOUT_MS) {
      awaitingReply = false;
      state = ST_MONITOR;
      sendTG("‚è±Ô∏è Cevap gelmedi. ƒ∞≈ülem yapƒ±lmadƒ±.");
    }
  }

  // AUTO alarm sorma kƒ±smƒ±
  if (state == ST_MONITOR && autoMode) {
    resetAlertLatchesIfNormal(mainsV);

    if (!lowAlertLatched && mainsV < MAINS_LOW_ALERT_V) {
      lowAlertLatched = true;
      askGeneratorQuestion("‚ö†Ô∏è ≈ûebeke gerilimi d√º≈ü√ºk!", mainsV);
      return;
    }

    if (!highAlertLatched && mainsV > MAINS_HIGH_ALERT_V) {
      highAlertLatched = true;
      askGeneratorQuestion("‚ö†Ô∏è ≈ûebeke gerilimi y√ºksek!", mainsV);
      return;
    }

    delay(300);
    return;
  }

  if (state == ST_MONITOR && !autoMode) {
    delay(500);
    return;
  }

  // "Evet" sonrasƒ± ≈üebeke kontrol
  if (state == ST_PRECHECK_AFTER_YES) {
    if (mainsV >= MAINS_OK_MIN_V && mainsV <= MAINS_OK_MAX_V) {
      sendTG("‚úÖ ≈ûebeke normale d√∂nm√º≈ü (" + String(mainsV,1) + "V). Jenerat√∂r √ßalƒ±≈ütƒ±rmƒ±yorum.");
      state = ST_MONITOR;
      return;
    }

    if (mainsV < MAINS_CRITICAL_V) {
      startProcedureBegin("≈üebeke <critical");
      return;
    }

    sendTG("‚ÑπÔ∏è ≈ûebeke " + String(mainsV,1) + "V. Kurala g√∂re i≈ülem yok (sadece <critical ise direkt ba≈ülat).");
    state = ST_MONITOR;
    return;
  }

  // Start prosed√ºr√º
  if (state == ST_STARTING) {
    if (millis() - lastGenCheckMs >= 1000) {
      lastGenCheckMs = millis();
      starterSecondCounter++;

      float g = readGenV();

      if (g > GEN_RUNNING_V) {
        starter(false);
        generatorRunning = true;
        genAboveCount = GEN_ON_CONFIRM_COUNT;
        genBelowCount = 0;
        lastPeriodicReportMs = millis();
        sendTG("‚úÖ Jenerat√∂r voltajƒ± geldi (" + String(g,1) + "V). Mar≈ü bƒ±rakƒ±ldƒ±. (IGN+FUEL a√ßƒ±k)");
        state = ST_MONITOR;
        return;
      }

      if (starterSecondCounter >= 5) {
        starter(false);
        sendTG("‚ùå 5sn mar≈üa raƒümen voltaj yok. 10sn soƒüutma, sonra tekrar deneyeceƒüim.");
        cooldownStartMs = millis();
        state = ST_COOLDOWN;
        return;
      }
    }
    delay(20);
    return;
  }

  if (state == ST_COOLDOWN) {
    if (millis() - cooldownStartMs >= 10000) {
      starterSecondCounter = 0;
      lastGenCheckMs = 0;
      starter(true);
      state = ST_STARTING;
      return;
    }
    delay(50);
    return;
  }

  if (state == ST_WAIT_REPLY) {
    delay(100);
    return;
  }
}
